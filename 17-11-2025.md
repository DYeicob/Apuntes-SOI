# 17/11/2025 — SOI

## Preguntas de clase

### Estrategias de reposición de páginas
- ¿Cuál estrategia requiere más **overhead**?
  - Aleatoria  
  - FIFO  
  - LRU → NUR  
- **La que más overhead requiere es LRU**, porque cada vez que se referencia una página es necesario actualizar punteros/estructuras, lo que puede incluso duplicar el tiempo de acceso.

---

### Tabla de páginas por proceso
- Cada trabajo tiene su **propia tabla de páginas**, que reside en **memoria principal (MP)**.
- Relación comentada en clase:

```
> tamaño máx. del programa
< nº de páginas del trabajo
< nº de filas de la tabla de páginas
< fragmentación de tablas
```

### ¿Por qué la tabla de páginas no tiene bits de protección?
- Porque **las páginas no tienen entidad semántica propia**: una misma página puede contener código o datos.
- Por ello, ciertos modelos no incluyen bits de protección a nivel de página; la protección se gestiona en otro nivel.

---

### Fragmentación según la estrategia usada
- Pregunta: *¿La paginación es la que requiere mayor fragmentación de tablas?*  
**Falso.**  
La mayor fragmentación se da en la **segmentación paginada**.

---

### Estrategias de colocación
- Pregunta: *¿Las estrategias de colocación de multiprogramación con particiones variables se usan en paginación?*  
**No.**  
En paginación, la memoria está dividida en **marcos de tamaño fijo**, por lo que no se buscan “huecos variables”.  
Se emplean:
- **Algoritmos de colocación en paginación**
- (En segmentación/paginada) selección de un marco libre para cada página del segmento

#### Implementaciones para gestionar marcos libres
1. **Vector de bits**  
 - Si hay `n` marcos, se usa un vector de `n` bits.  
 - Cada bit indica:
   - `0` → ocupado  
   - `1` → libre  
   *(o viceversa, según el S.O.)*  
 - El sistema busca el **primer marco libre** recorriendo el vector.

2. **Lista de marcos libres**  
 - Se mantiene una lista enlazada (o estructura similar) con todos los marcos disponibles.  
 - Permite asignar rápidamente el primer marco libre sin recorrer toda la memoria.

---

## 5.3.3 Localidad

Cuando un proceso hace referencia a direcciones virtuales, **no sigue patrones uniformes**.  
Existen dos tipos principales de localidad:

### Localidad en el tiempo
- Una zona de memoria **referenciada recientemente** tiene una alta probabilidad de ser **referenciada de nuevo en un futuro próximo**.

### Localidad en el espacio
- Una vez hecha una referencia a una zona determinada, es probable que **zonas cercanas** también sean referenciadas.

---

## Teoría del conjunto de trabajo (Denning)

La teoría del conjunto de trabajo describe el comportamiento dinámico de un programa en cuanto al uso de páginas.

- El **conjunto de trabajo** es el **conjunto de páginas** a las cuales un proceso está haciendo referencia **activamente**.
- Este conjunto **cambia durante la ejecución** del proceso.
- Por lo tanto, cualquier suposición sobre:
  - el **tamaño** del conjunto de trabajo inicial, o  
  - su **contenido, no se puede aplicar a los sucesivos conjuntos de trabajo** del mismo proceso, ya que evolucionan conforme cambia su patrón de acceso a memoria.
 

---


# Tema 4 — Visión del Usuario

## 1. Visión del usuario (I)

Cada dispositivo tiene su propia organización interna.  
El sistema operativo utiliza **abstracciones** para proporcionar al usuario un entorno más cómodo y uniforme.

---

## 1.1. Concepto de fichero (I)

### Definiciones

- Un **fichero** es un conjunto de información con cierta entidad, pensado para su conservación y uso en un entorno informático.  
- La información contenida en un fichero se puede referenciar como un todo mediante un **nombre**, que lo identifica.
- El **sistema de ficheros** es la parte del S.O. encargada de gestionar los datos almacenados en el **almacenamiento secundario**.

### Funciones que debe ofrecer el sistema de ficheros
1. Permitir que los usuarios puedan crear, borrar y modificar sus ficheros.  
2. Permitir que los usuarios referencien sus ficheros mediante **nombres simbólicos**.  
3. Permitir que los usuarios puedan **estructurar** sus ficheros.
4. Permitir ordenar la transferencia de información entre ficheros.  
5. Ofrecer una **interfaz amable**, proporcionando una vista **lógica** de los datos y de las funciones disponibles.  
6. Realizar operaciones sobre datos de forma **independiente del dispositivo físico**.  
7. Permitir que los usuarios **compartan** sus ficheros de forma controlada.  
8. Proporcionar diferentes tipos de **acceso controlado** para la compartición.  
9. Proporcionar recursos para **respaldos** (backups) y **recuperación** de información.  
10. Ofrecer **cifrado y descifrado** para garantizar seguridad y privacidad.  
11. Gestionar la **memoria secundaria**.

---

## 1.2. Organización lógica de los ficheros

### Definición
La **organización lógica** de un fichero se refiere a cómo se disponen sus registros en el almacenamiento secundario, desde el punto de vista del **acceso lógico** del usuario.

### Organizaciones comunes

#### A. Acceso secuencial
- La información se procesa en **orden consecutivo**.  
- Una lectura devuelve el **siguiente registro**.  
- Una escritura **añade** un registro al final del fichero.

#### B. Acceso directo
- Se accede a los registros **sin seguir un orden**, usando una **clave**.  
- Si la clave es única, existen dos métodos:

##### ● Direccionamiento disperso (hashing)
- Se utiliza una función que, tomando la clave como entrada, devuelve la **dirección física** del registro.

##### ● Fichero indexado
- Existe una **tabla índice** donde el **orden de las claves es significativo**.  
- Permite localizar registros rápidamente a partir de esa tabla.


---


## 1.3. Estructura del sistema de ficheros (I)

- El **nombre simbólico** de un fichero puede estar formado por una **raíz** y una **extensión**.
- Un **directorio** es una estructura que permite **organizar** los ficheros del sistema.
- Los nombres de los ficheros deben ser **únicos dentro del mismo directorio**.
- Para identificar un fichero o directorio es necesario proporcionar su **ruta completa** (pathname), partiendo del directorio raíz.

**Ejemplo:**  
`\Directorio1\Directorio3\Fichero4`

---

## 1. Visión del usuario (IV)

_Estructura jerárquica de ejemplo:_

```

Raíz ()
├── Directorio1
│   ├── Fichero1
│   ├── Fichero2
│   └── Directorio3
│       └── Fichero4
└── Directorio2
└── Fichero3

```

---

## 1.3. Estructura del sistema de ficheros (II)

### Conceptos

1. **Directorio de trabajo actual** (working directory):  
   - Es el directorio desde el cual el usuario o proceso trabaja por defecto.  
   - Es posible referenciar rutas **relativas** tomando como punto de partida este directorio.  
   - Ejemplo: si el directorio de trabajo es `Directorio1`, la ruta relativa a `Directorio3\Fichero4` es válida.

2. **Lista de búsqueda**  
   - A cada proceso se le asigna una lista de directorios.  
   - Si un fichero no se encuentra en el directorio de trabajo, se busca en esta lista.

3. **Ficheros que hacen referencia a dispositivos de E/S**  
   - Algunos sistemas representan dispositivos de entrada/salida como **ficheros especiales**.

4. **Enlace (Link)**  
   - Mecanismo que permite que un fichero aparezca en **dos puntos distintos** de la estructura sin duplicar su contenido.

---

## 1. Visión del usuario (V)

_Otra vista jerárquica simplificada:_

```

Raíz ()
├── Directorio1
│   ├── Fichero1
│   └── Fichero2
└── Directorio2

```

---

## 1.4. Generalización de los servicios del sistema de ficheros

### Gestión de directorios
1. Crear un directorio  
2. Borrar un directorio  
3. Visualizar los elementos que dependen de un directorio  
4. (Opcional) Cambiar el nombre de un directorio  

### Gestión del directorio de trabajo
1. Visualizar el directorio actual  
2. Modificar el directorio de trabajo  

### Gestión de la lista de búsqueda
1. Visualizar la lista de búsqueda  
2. Modificar la lista de búsqueda  

### Gestión de enlaces
1. Crear un enlace  
2. Borrar un enlace  

---

## 4. Integridad y protección del sistema de ficheros (I)

### 4.1. Seguridad e integridad — Métodos (I)

**Definición:**  
La **integridad** implica que toda la información del sistema de ficheros debe ser **consistente**.

### Problemas comunes

1. **Fallo en la superficie del dispositivo**  
   - El sistema de ficheros queda **incompleto**.

2. **Errores en lectura o escritura**  
   - El sistema de ficheros está completo, pero **no consistente**.

3. **Fallo del sistema global**  
   - El sistema de ficheros queda **no consistente**.
