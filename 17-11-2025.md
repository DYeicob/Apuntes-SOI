# 17/11/2025 — SOI

## Preguntas de clase

### Estrategias de reposición de páginas
- ¿Cuál estrategia requiere más **overhead**?
  - Aleatoria  
  - FIFO  
  - LRU → NUR  
- **La que más overhead requiere es LRU**, porque cada vez que se referencia una página es necesario actualizar punteros/estructuras, lo que puede incluso duplicar el tiempo de acceso.

---

### Tabla de páginas por proceso
- Cada trabajo tiene su **propia tabla de páginas**, que reside en **memoria principal (MP)**.
- Relación comentada en clase:

```
> tamaño máx. del programa
< nº de páginas del trabajo
< nº de filas de la tabla de páginas
< fragmentación de tablas
```

### ¿Por qué la tabla de páginas no tiene bits de protección?
- Porque **las páginas no tienen entidad semántica propia**: una misma página puede contener código o datos.
- Por ello, ciertos modelos no incluyen bits de protección a nivel de página; la protección se gestiona en otro nivel.

---

### Fragmentación según la estrategia usada
- Pregunta: *¿La paginación es la que requiere mayor fragmentación de tablas?*  
**Falso.**  
La mayor fragmentación se da en la **segmentación paginada**.

---

### Estrategias de colocación
- Pregunta: *¿Las estrategias de colocación de multiprogramación con particiones variables se usan en paginación?*  
**No.**  
En paginación, la memoria está dividida en **marcos de tamaño fijo**, por lo que no se buscan “huecos variables”.  
Se emplean:
- **Algoritmos de colocación en paginación**
- (En segmentación/paginada) selección de un marco libre para cada página del segmento

#### Implementaciones para gestionar marcos libres
1. **Vector de bits**  
 - Si hay `n` marcos, se usa un vector de `n` bits.  
 - Cada bit indica:
   - `0` → ocupado  
   - `1` → libre  
   *(o viceversa, según el S.O.)*  
 - El sistema busca el **primer marco libre** recorriendo el vector.

2. **Lista de marcos libres**  
 - Se mantiene una lista enlazada (o estructura similar) con todos los marcos disponibles.  
 - Permite asignar rápidamente el primer marco libre sin recorrer toda la memoria.

---

## 5.3.3 Localidad

Cuando un proceso hace referencia a direcciones virtuales, **no sigue patrones uniformes**.  
Existen dos tipos principales de localidad:

### Localidad en el tiempo
- Una zona de memoria **referenciada recientemente** tiene una alta probabilidad de ser **referenciada de nuevo en un futuro próximo**.

### Localidad en el espacio
- Una vez hecha una referencia a una zona determinada, es probable que **zonas cercanas** también sean referenciadas.

---

## Teoría del conjunto de trabajo (Denning)

La teoría del conjunto de trabajo describe el comportamiento dinámico de un programa en cuanto al uso de páginas.

- El **conjunto de trabajo** es el **conjunto de páginas** a las cuales un proceso está haciendo referencia **activamente**.
- Este conjunto **cambia durante la ejecución** del proceso.
- Por lo tanto, cualquier suposición sobre:
  - el **tamaño** del conjunto de trabajo inicial, o  
  - su **contenido, no se puede aplicar a los sucesivos conjuntos de trabajo** del mismo proceso, ya que evolucionan conforme cambia su patrón de acceso a memoria.
